// Auto-generated by scripts/generate-tabs.js
// DO NOT EDIT THIS FILE MANUALLY - Edit tabs.config.json instead and run: yarn generate-tabs

import { Tab } from '@/types';

export const tabs: Tab[] = [
  {
    "title": "Example Usage",
    "content": "import { useState } from 'react';\nimport { Page, Layout } from '@shopify/polaris';\nimport { SortableList } from './SortableList';\n\nexport const Example = () => {\n  const [items, setItems] = useState([\n    { id: 1, title: 'T-Shirt', status: 'active' },\n    { id: 2, title: 'Skateboard', status: 'active' },\n    { id: 3, title: 'Snowboard', status: 'archived' },\n    { id: 4, title: 'Ultimate Snowboard', status: 'active' },\n    { id: 5, title: 'Mechanical Pencil', status: 'draft' }\n  ]);\n\n  return (\n    <Page narrowWidth>\n      <Layout>\n        <Layout.Section>\n          <SortableList items={items} setItems={setItems} />\n        </Layout.Section>\n      </Layout>\n    </Page>\n  );\n};\n",
    "lang": "jsx"
  },
  {
    "title": "SortableList.jsx",
    "content": "import {\n  BlockStack,\n  Card,\n  ResourceList,\n  Text,\n  ResourceItem,\n  Avatar,\n  Box,\n  InlineStack,\n  Badge,\n  Button\n} from '@shopify/polaris';\nimport { DragHandleIcon, XIcon } from \"@shopify/polaris-icons\";\nimport {\n  DndContext,\n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors\n} from '@dnd-kit/core';\nimport {\n  arrayMove,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  verticalListSortingStrategy,\n  useSortable\n} from '@dnd-kit/sortable';\nimport { restrictToVerticalAxis, restrictToParentElement } from '@dnd-kit/modifiers';\nimport styles from './SortableList.module.css';\n\nconst Item = ({ id, title, status }) => {\n  const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({\n    id\n  });\n\n  const tone = status === 'active' ? 'success' : status === 'draft' ? 'info' : undefined;\n\n  const style = {\n    ...(transform\n      ? {\n          transform: `translate3d(${transform.x}px, ${transform.y}px, 0)`,\n          transition\n        }\n      : {}),\n    zIndex: isDragging ? 1000 : 0,\n    position: 'relative'\n  };\n\n  return (\n    <div style={style} ref={setNodeRef}>\n      <ResourceItem\n        id={id}\n        accessibilityLabel={`View details for ${title}`}\n        onClick={() => console.log('Handle item click')}\n      >\n        <InlineStack align='space-between' blockAlign='center'>\n          <InlineStack gap='400' blockAlign='center'>\n            {/* Build your own implementation of the ResourceItem, but preserve this drag handle div as the first item in the InlineStack */}\n            <div\n              {...attributes}\n              {...listeners}\n              onClick={(e) => e.stopPropagation()}\n              className={styles.itemAction}\n              style={{ touchAction: 'none', display: 'flex' }} // Prevents page scrolling on mobile touch\n            >\n              <DragHandleIcon width='20' height='20' />\n            </div>\n            {/* Don't use `media` prop of ResourceItem, if you need to you can place your Avatar or Image here instead after the DragHandler */}\n            <Avatar size='md' name={title} />\n            <Text variant='bodyMd' as='h3'>\n              {title}\n            </Text>\n          </InlineStack>\n          <InlineStack gap='400'>\n            <Badge tone={tone} size='small'>\n              {`${status.charAt(0).toUpperCase()}${status.slice(1)}`}\n            </Badge>\n            <div\n              style={{ width: 20, height: 20 }}\n              className={styles.itemAction}\n              onClick={(e) => {\n                e.stopPropagation();\n                console.log('Remove Item');\n              }}\n            >\n              <Button icon={XIcon} variant='monochromePlain'></Button>\n            </div>\n          </InlineStack>\n        </InlineStack>\n      </ResourceItem>\n    </div>\n  );\n};\n\nexport const SortableList = ({ items, setItems }) => {\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates\n    })\n  );\n\n  const handleDragEnd = (event) => {\n    const { active, over } = event;\n\n    if (active.id !== over.id) {\n      // Updates items in state, add additional update handler logic here (e.g. API calls, toasts, etc.)\n      setItems((items) => {\n        const oldIndex = items.findIndex((item) => item.id === active.id);\n        const newIndex = items.findIndex((item) => item.id === over.id);\n        const updatedItems = arrayMove(items, oldIndex, newIndex);\n\n        return updatedItems;\n      });\n    }\n  };\n\n  return (\n    <Card padding='0'>\n      <BlockStack gap='300'>\n        <Box paddingBlockStart='300' paddingInlineStart='300' zIndex='100'>\n          <Text as='h3' variant='headingSm'>\n            Sortable Products\n          </Text>\n        </Box>\n        <DndContext\n          sensors={sensors}\n          collisionDetection={closestCenter}\n          onDragEnd={handleDragEnd}\n          modifiers={[restrictToVerticalAxis, restrictToParentElement]}\n        >\n          <SortableContext items={items} strategy={verticalListSortingStrategy}>\n            <ResourceList\n              resourceName={{ singular: 'customer', plural: 'customers' }}\n              items={items}\n              renderItem={(item) => {\n                return <Item {...item} />;\n              }}\n            />\n          </SortableContext>\n        </DndContext>\n      </BlockStack>\n    </Card>\n  );\n};\n",
    "lang": "jsx"
  },
  {
    "title": "SortableList.module.css",
    "content": "/* If using CSS modules in Remix, make sure you have configured CSS bundling (https://remix.run/docs/en/main/styling/bundling) */\n\n.itemAction {\n  opacity: 0.6;\n}\n\n.itemAction:hover {\n  opacity: 1;\n}\n",
    "lang": "css"
  }
];
